# 组件实现与挂载

- babel调用React.createElement将我们的jsx转化为ReactElement

开发环境下createElement调用createElementWithValidation（react-16.3.0\packages\react\src\ReactElementValidator.js）这个函数进行一些验证后，最后还是会调用createElement（react-16.3.0\packages\react\src\ReactElement.js），生产直接调用createElement，最后返回一个ReactElement

- ReactDOM.render调用，将挂载组件

实际调用函数legacyRenderSubtreeIntoContainer（react-16.3.0\packages\react-dom\src\client\ReactDOM.js）

----得到root=container._reactRootContainer=legacyCreateRootFromDOMContainer(container, forceHydrate)（react-16.3.0\packages\react-dom\src\client\ReactDOM.js）;

--------legacyCreateRootFromDOMContainer 返回 new ReactRoot() （react-16.3.0\packages\react-dom\src\client\ReactDOM.js）

------------这个返回的对象上有一个属性_internalRoot为DOMRenderer.createContainer()函数的返回值

----------------DOMRenderer就是ReactFiberReconciler()（react-16.3.0\packages\react-reconciler\src\ReactFiberReconciler.js）的返回值

------------DOMRenderer.createContainer()实质是调用createFiberRoot()（react-16.3.0\packages\react-reconciler\src\ReactFiberRoot.js）返回了一个FiberRoot对象

------------还绑定了一些其他的方法：render,unmount,legacy_renderSubtreeIntoContainer,createBatch,

----接着调用DOMRenderer.unbatchedUpdates(fn, a),执行fn(a)并将结果返回，实际执行了root.render(children, callback);

--------函数中获取work = new ReactWork(),这个对象上绑定了_onCommit方法，最后调用DOMRenderer.updateContainer(children, root, null, work._onCommit)，返回updateContainerAtExpirationTime()调用的结果，返回scheduleRootUpdate()调用的结果，是expirationTime;

--------root.render(children, callback)最后返回的是一个work对象

----最后调用DOMRenderer.getPublicRootInstance(root._internalRoot)，并返回结果

